---
title: 设计模式归纳
date: 2021-10-14 21:41:50
tags:
  - design-patterns
  - methods
---


# 创建型 creational-patterns

## 抽象工厂 abstract-factory

由简单工厂演变，基于一组工厂方法的抽象；相似的却不同的多个产品类，就会有多个工厂泪，工厂的抽象则为抽象工厂。

汽车举例：两种类型的汽车，轿车和卡车，两个品牌的汽车，奔驰和宝马，如果每个品牌的每个类型单独实现，则需要四个实现，扩展不方便。可以分别创建类型的工厂和品牌的工厂（产品工厂类），此时在对两个工厂类再创建一个工厂类（工厂的的工厂类），使用时先通过产品工厂的工厂类获取产品工厂类，通过产品工厂类就可以获取产品。

## 生成器 builder

复杂的多个步骤构建的对象，主管类使用生成器执行定义好的流程进行构建（可选），角色：builder、director

汽车举例：两种汽车，生产步骤相同，具体实现不同，比如汽车燃料有是电池，有是汽油，驱动器有是电机，有是发动机，中空有是触屏，有是按钮，等等。生产过程可以拆成多个步骤（生成器类builder），不同的汽车用不同的生成器，单个步骤负责单个零件模块（生成器中的一个方法），流水线从头开始逐个模块执行（主管类director），流水线走完，汽车创建完成

房子举例：建房子，主要内容相同，具体实现不同，比如房子是一个铁窗，有个房子是两个铝合金窗，门有的是木质推拉门，有的是铁质卷帘门，等等。建造过程拆成多个步骤（生成器类builder），不同的房子不同的生成器，单个步骤负责单个部件（生成器中的一个方法），建造开始，工程师根据房子建造的顺序逐个执行（主管类director），所有步骤执行完，房子创建完成

## 原型 prototype

一句话：产品内部封闭，用户无法克隆产品，此时需要产品内部实现克隆方法，原始对象即为原型。

## 单例 singleton

### 饿汉
一句话：饥饿状态，一开始初始化
### 饱汉
一句话：吃饱状态，需要时初始化
### DLC
一句话：双重检查锁，先检查避免资源浪费，加锁后在检查是为了避免加锁成功后对象已被初始化

# 结构型 structural-patterns

## 适配器 adapter

通常在已有程序中使用适配器来整合两个类，如果两个类比较相似，可以通过继承进行结合，相差比较大则通过适配器类进行结合：创建客户端使用的适配接口，实现类中引用服务对象进行适配；作用是对原有代码进行兼容。

## 桥接 bridge

多为前期开发时使用，方便模块独立开来进行开发工作。分为抽象部分（抽象类，主控制）和实现部分（接口，主产品），抽象部分是一些产品实体的高阶控制层，不负责任何具体的工作，具体的任务交给实现部分去执行：某产品实现引用的是其他功能的抽象类或接口，而不是饮用具体的实现。

## 组合 composite

核心功能是一个树形结构，分解成简单实现（叶节点）和复杂实现（容器类），复杂实现是其他实现（简单、复杂）的聚合，通过集合来存储，并且包含相同的方法，容器只负责少量工作，大量工作交给聚合的其他子类。


## 装饰 decorator

无需修改原有代码，可以新增额外的行为；在无法通过继承来扩展原有对象时，使用装饰器（Decorator）。使用方法：创建装饰器基类，创建成员变量引用原有对象，运行时装饰器负责调用被封装的对象，封装后的提供的是装饰器定义的行为；作用是可以更改对象的外表。

## 外观 facade

子系统随时间推移，代码量大，应用设计模式达到灵活或可复用，但是调用方式很复杂，对这样的子系统对外提供一个外观，多个子系统间可以通过外观进行交互。外观的行为给客户端提供调用，具体实现是对子系统逻辑的调用。优点：复杂子系统相对独立；缺点：外观可能成为所有类耦合得到的上帝对象；通常会作用于整个对象子系统上。

## 享元 flyweight

对象初始化后不会被改变，通常用于程序中大量相同对象，具备该属性的产品都引用同一个对象；简单理解为缓存和复用相同的对象。

## 代理 proxy

一般通过服务接口的实现类来实现代理，这样可以在实现代理的同时完成服务的具体实现。创建成员变量引用被代理对象。或者可以直接继承被代理对象；能为对象提供相同的接口。

# 行为型 behavioral-patterns

## 责任链 chain-of-responsibility

一个请求，多个处理者，顺序固定，处理者固定；或者都不固定时，需要增加变量的修改方法，提供修改处理者或执行顺序的方法。作用是将请求动态传递给一系列的潜在接收者，直至某个处理者对请求进行处理。

## 命令 command

触发者（invoker）发送命令（command）给接收者（receiver），实现回滚功能时可以使用，需要将操作放入队列或远端执行是可以使用。作用在命令发送者和接受者建立单向关系。

## 迭代器 iterator

主要将集合的遍历行为抽取为单独的迭代器（iterator）对象，迭代器内部包含遍历操作的所有细节；可以隐藏背后复杂的数据结构，可以遍历不同的无法预知的数据结构。

## 中介者 mediator

通过一个中介者来建立连接，其内包含多个独立组件的逻辑关系，组件A通过调用中介者，中介者调用组件B，将多个组件的联系中心化，组件面对的是中介者，而不是具体的被调方，可以增加组件的可复用性；命令和观察者都是单方向传递，中介者可以相互传递的。

## 备忘录 memento

简单实现就是将对象序列化或其他方式存储起来，之后某个时间可以恢复到存储时的状态；严格的实现分为存储者（备忘录），发起者（Originator），监管者（Caretaker），发起者将备忘录发给监管者保存起来。

## 观察者 observer

发布者发出消息（publisher），订阅者（subscribers）接收消息；作用在接收者可以动态地订阅或取消订阅，是单向传递的。

## 策略 strategy

方法有多个不同的实现在调用逻辑上可以用策略模式；创建策略类，其内包含策略的算法，可以将方法实现和方法调的逻辑分开，运行时可以根据策略算法调用不同的实现。

## 模板方法 template-method

基于继承机制，抽象类实现的是相对通用的方法，也是相对封闭的，仅提供抽象方法或开放允许被修改的方法，子类继承时实现抽象方法和修改某些方法的实现。

## 访问者 visitor

多个产品，多种操作类型，不同的操作类型创建不同的访问者，访问者包含对所有产品的访问方法





参考：

- https://refactoringguru.cn/design-patterns

- https://github1s.com/iluwatar/java-design-patterns
